// Confirm payment and finalize ticket booking
// This edge function is called after successful payment

Deno.serve(async (req) => {
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
    'Access-Control-Max-Age': '86400',
  };

  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { paymentIntentId, bookingId } = await req.json();

    console.log('Payment confirmation request:', { paymentIntentId, bookingId });

    if (!paymentIntentId || !bookingId) {
      throw new Error('Payment intent ID and booking ID are required');
    }

    const stripeSecretKey = Deno.env.get('STRIPE_SECRET_KEY');
    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const serviceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');

    // For demo mode
    if (!stripeSecretKey) {
      console.log('Demo mode: Confirming payment without Stripe');
      
      // Update booking to confirmed
      const updateResponse = await fetch(`${supabaseUrl}/rest/v1/tickets?id=eq.${bookingId}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${serviceRoleKey}`,
          'apikey': serviceRoleKey,
          'Content-Type': 'application/json',
          'Prefer': 'return=representation'
        },
        body: JSON.stringify({
          payment_status: 'completed',
          booking_status: 'confirmed',
          confirmed_at: new Date().toISOString()
        })
      });

      if (!updateResponse.ok) {
        throw new Error('Failed to update booking status');
      }

      const updatedBooking = await updateResponse.json();

      return new Response(JSON.stringify({
        data: {
          ticketId: bookingId,
          status: 'confirmed',
          isDemoMode: true,
          booking: updatedBooking[0]
        }
      }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // Verify payment with Stripe
    const paymentIntentResponse = await fetch(
      `https://api.stripe.com/v1/payment_intents/${paymentIntentId}`,
      {
        headers: {
          'Authorization': `Bearer ${stripeSecretKey}`
        }
      }
    );

    if (!paymentIntentResponse.ok) {
      throw new Error('Failed to verify payment with Stripe');
    }

    const paymentIntent = await paymentIntentResponse.json();

    // Check payment status
    if (paymentIntent.status !== 'succeeded') {
      throw new Error(`Payment not completed. Status: ${paymentIntent.status}`);
    }

    console.log('Payment verified as successful');

    // Update booking to confirmed
    const updateResponse = await fetch(`${supabaseUrl}/rest/v1/tickets?id=eq.${bookingId}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${serviceRoleKey}`,
        'apikey': serviceRoleKey,
        'Content-Type': 'application/json',
        'Prefer': 'return=representation'
      },
      body: JSON.stringify({
        payment_status: 'completed',
        booking_status: 'confirmed',
        confirmed_at: new Date().toISOString(),
        stripe_charge_id: paymentIntent.latest_charge || null
      })
    });

    if (!updateResponse.ok) {
      const errorText = await updateResponse.text();
      console.error('Failed to update booking:', errorText);
      throw new Error('Failed to confirm booking');
    }

    const updatedBooking = await updateResponse.json();
    console.log('Booking confirmed:', updatedBooking[0].id);

    return new Response(JSON.stringify({
      data: {
        ticketId: bookingId,
        status: 'confirmed',
        paymentStatus: paymentIntent.status,
        booking: updatedBooking[0]
      }
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('Payment confirmation error:', error);
    
    return new Response(JSON.stringify({
      error: {
        code: 'PAYMENT_CONFIRMATION_FAILED',
        message: error.message,
        timestamp: new Date().toISOString()
      }
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
});
